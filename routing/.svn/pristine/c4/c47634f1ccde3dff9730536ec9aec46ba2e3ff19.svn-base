#include <limits.h>

#include <algorithm>
#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <typeinfo>
#include <vector>

// A node object used store the name, neighbours + costs etc
class node {
 public:
  node();
  node(std::string x);
  std::string name;
  // A vector of a string int pair storing its neighbour nodes and weight
  std::map<std::string, int> neighbour_nodes;
  // LSDB table storing all links the node has access to
  std::map<std::string, int> lsdb;
  // Routing table storing the shortest route the nodes can take for different
  // destination nodes;
  std::vector<std::vector<std::string> > routing;
};

// default constructor
node::node(){};

// constructor with name parameter
node::node(std::string x) { name = x; };

// helper function used to add neighbour to specific node
void update_neighbours(node& node1, node& node2, int weight) {
  node1.neighbour_nodes[node2.name] = weight;
  // std::cout << "node1 neighbour: "<< node1.neighbour_nodes[node2.name]
  // <<std::endl;
  node2.neighbour_nodes[node1.name] = weight;
  // std::cout << "node2 neighbour node 1: "<< node2.neighbour_nodes[node1.name]
  // <<std::endl;
};

void remove_neighbour(node& node1, node& node2) {
  node1.neighbour_nodes.erase(node2.name);
  node2.neighbour_nodes.erase(node1.name);
}

// helper function used to remove an element from a string vector
std::vector<std::string> remove_element(std::vector<std::string> vec,
                                        std::string val) {
  std::vector<std::string>::iterator position =
      find(vec.begin(), vec.end(), val);
  if (position !=
      vec.end()) {  // == myVector.end() means the element was not found
    vec.erase(position);
  }
  return vec;
};

node create_node(std::string input) {
  std::vector<node> all_nodes;
  node temp(input);
  return temp;
};

void print_neighbour_table(node& x) {
  std::vector<std::pair<std::string, int> > neighbours_sorted(
      x.neighbour_nodes.begin(), x.neighbour_nodes.end());
  std::cout << x.name << " Neighbour Table:" << std::endl;
  if (x.neighbour_nodes.empty()) {
    std::cout << std::endl;
  } else {
    for (auto& neighbour_node : neighbours_sorted) {
      std::cout << neighbour_node.first << "|" << neighbour_node.second
                << std::endl;
    }
  }
  std::cout << std::endl;
};

void print_lsdb_table(node& x) {
  std::cout << x.name << " LSDB Table:" << std::endl;
  if (x.lsdb.empty()) {
    std::cout << std::endl;
  } else {
  };
  std::cout << std::endl;
};

void print_routing_table(node& x) {
  std::cout << x.name << " Routing Table:" << std::endl;
  if (x.routing.empty()) {
    std::cout << std::endl;
  } else {
  }
  std::cout << std::endl;
};

// used to find the previous node
// std::string prev_node(std::unordered_map<std::string, int> cost_arr){};

// calculates the final cost of a route from start to finish, requires the full
// node route int calc_cost(node start, node dest){};

/*
At each node x:
INITIALISATION:
N’ = {u}
for all nodes v
    if v is a neighbor of u
        then D(v) = c(u,v)
    else D(v) = ∞

LOOP
find w not in N' such that D(w) is a minimum
add w to N’
update D(v) for each neighbor v of w and not in N':
    D(v) = min(D(v), D(w) + c(w,v))
    new cost to v is either old cost to v or known least path cost to w plus
cost from w to v until N' = N
*/

std::vector<node> dijkstra(node starting, std::vector<std::string> all_nodes,
                           int node_num) {
  all_nodes.push_back(starting.name);
  // creates the N’ array storing the order
  std::vector<node> final;
  final.push_back(starting);
  std::unordered_map<std::string, int> cost_arr;
  // initialising
  for (int i = 0; i < node_num; i++) {
    std::string curr_node = all_nodes[i];
    if ((starting.neighbour_nodes).find(curr_node) !=
        starting.neighbour_nodes.end()) {
      cost_arr[curr_node] = starting.neighbour_nodes[curr_node];
    } else {
      cost_arr[curr_node] = INT_MAX;
    }
  }

  // create a vector of vector names that can be removed as the min is found and
  // remove the starting node as its already in the final node
  std::vector<std::string> remaining_nodes = all_nodes;
  remaining_nodes = remove_element(remaining_nodes, starting.name);

  // for loop after initiation
  for (int i = 0; i < node_num - 1; i++) {
    int min_weight = INT_MAX;
    // for(int j = 0; j > remaining_nodes.size(); j++){

    // find w not in N' such that D(w) is a minimum
    // if()
    // add w to N’

    // update D(v) for each neighbor v of w and not in N':
    // D(v) = min(D(v), D(w) + c(w,v))
    //}
  }

  return final;
};

void print_test(node x) {
  std::cout << "name: " << x.name << std::endl;
  std::cout << "neighbour_nodes number: " << x.neighbour_nodes.size()
            << std::endl;
  for (auto i = x.neighbour_nodes.begin(); i != x.neighbour_nodes.end(); i++) {
    std::cout << i->first << " \t\t\t" << i->second << std::endl;
  }
};

void print_tables(std::string token, std::map<std::string, node> all_nodes) {
  std::string print_variables = token;
  std::stringstream check3(print_variables);
  std::string curr;
  while (getline(check3, print_variables, ',')) {
    print_neighbour_table(all_nodes[print_variables]);
    print_lsdb_table(all_nodes[print_variables]);
    print_routing_table(all_nodes[print_variables]);
  }
};

void process_input() {
  // used to link nodes to a name
  std::map<std::string, node> all_nodes;

  std::vector<std::string> input;
  std::string str;
  while (getline(std::cin, str)) {
    if (str.empty()) {
      break;
    }
    input.push_back(str);
  }

  int i = 0;
  // creating new nodes for every line until LINKSTATE
  while (input[i] != "LINKSTATE") {
    node temp(input[i]);
    all_nodes[input[i]] = temp;
    i++;
  }
  i++;

  // creating links until UPDATE
  while (input[i] != "UPDATE") {
    // Vector of string to save tokens
    std::string line = input[i];
    std::vector<std::string> tokens;

    std::stringstream check1(line);
    std::string current;

    // tokenises by the space into X-Z, 1, x,y
    while (getline(check1, current, ' ')) {
      tokens.push_back(current);
    }
    // get the first and second node sperated by the -
    std::string node1 = tokens[0].substr(0, tokens[0].find("-"));
    std::string node2 = tokens[0].substr(tokens[0].find("-") + 1);

    // find the weight and add to tables accordingly
    int weight = stoi(tokens[1]);
    if (weight == -1 && all_nodes[node1].neighbour_nodes.find(node2) !=
                            all_nodes[node1].neighbour_nodes.end()) {
      std::cout << "removed: " << node1 << std::endl;
      remove_neighbour(all_nodes[node1], all_nodes[node2]);
    } else {
      update_neighbours(all_nodes[node1], all_nodes[node2], weight);
    }
    // if there is an optional list, print each variable's tables
    tokens.push_back(" ");
    if (tokens[2] != " ") {
      print_tables(tokens[2], all_nodes);
    }
    i++;
  }
  i++;

  // updating links until END
  while (input[i] != "END") {
    std::string line = input[i];
    std::vector<std::string> tokens;

    std::stringstream check1(line);
    std::string current;

    // tokenises by the space into X-Z, 1, x,y
    while (getline(check1, current, ' ')) {
      tokens.push_back(current);
    }
    // get the first and second node sperated by the -
    std::string node1 = tokens[0].substr(0, tokens[0].find("-"));
    std::string node2 = tokens[0].substr(tokens[0].find("-") + 1);

    // find the weight and add to tables accordingly
    int weight = stoi(tokens[1]);
    if (weight == -1 && all_nodes[node1].neighbour_nodes.find(node2) !=
                            all_nodes[node1].neighbour_nodes.end()) {
      std::cout << "removed: " << node1 << std::endl;
      remove_neighbour(all_nodes[node1], all_nodes[node2]);
    } else {
      update_neighbours(all_nodes[node1], all_nodes[node2], weight);
    }

    // if there is an optional list, print each variable's tables
    tokens.push_back(" ");
    if (tokens[2] != " ") {
      print_tables(tokens[2], all_nodes);
    }
    i++;
  }
};

int main() {
  process_input();
  return 0;
}
