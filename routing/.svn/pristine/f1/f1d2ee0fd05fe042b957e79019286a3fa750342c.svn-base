#include <iostream>
#include <vector>
#include <unordered_map>
#include <limits.h>
#include <algorithm>
#include <string>

//A node object used store the name, neighbours + costs etc
class node{
  public:
    node();
    node(std::string x);
    std::string name;
    // A vector of a string int pair storing its neighbour nodes and weight
    std::unordered_map<std::string, int> neighbour_nodes;
    // LSDB table storing all links the node has access to
    std::unordered_map<std::string, int> lsdb;
    // Routing table storing the shortest route the nodes can take for different destination nodes;
    std::vector<std::vector<std::string> > routing;
};

//default constructor
node::node(){};

//constructor with name parameter
node::node(std::string x){
  name = x;
};

//helper function used to add neighbour to specific node
void add_neighbours(node current, std::string neighbour_name, int weight){
  current.neighbour_nodes[neighbour_name] = weight;
};

//helper function used to remove an element from a string vector
std::vector<std::string> remove_element(std::vector<std::string> vec, std::string val){
  std::vector<std::string>::iterator position = find(vec.begin(), vec.end(), val);
  if (position != vec.end()){ // == myVector.end() means the element was not found
    vec.erase(position);
  }
  return vec;
};

node create_node(std::string input){
  std::vector<node> all_nodes;
  node temp(input);
  return temp;
};

void process_input(){
  std::vector<std::string> input;
  std::string str;
  std::vector<node> all_nodes;
  while (getline(std::cin, str)) { 
        if (str.empty()) { 
            break; 
        } 
        input.push_back(str); 
    } 
    int i = 0;
    //creating new nodes for every line until LINKSTATE
    while(input[i] != "LINKSTATE"){
      std::cout << input[i] << std::endl;
      node temp(input[i]);
      all_nodes.push_back(temp);
      i++;
    }
    //creating links until UPDATE
    i++;
    while(input[i] != "UPDATE"){
      std::cout << input[i] << std::endl;
      //do something
      i++;
    }
    //updating links until END
    i++;
    while(input[i] != "END"){
      std::cout << input[i] << std::endl;
     //do something
     i++;
    }

  
};

//used to find the previous node
std::string prev_node(std::unordered_map<std::string, int> cost_arr){
  
}

//calculates the final cost of a route from start to finish, requires the full node route
int calc_cost(node start, node dest){

};

void neighbour_table(node x){
  std::vector<std::pair<std::string, int>> neighbours_sorted(x.neighbour_nodes.begin(), x.neighbour_nodes.end());
  for(auto& neighbour_node : neighbours_sorted){
    std::cout << neighbour_node.first << "|" << neighbour_node.second << std::endl;
  }
};

void lsdb_table(node x){};

void routing_table(node x){};

/*
At each node x:
INITIALISATION:
N’ = {u} 
for all nodes v 
    if v is a neighbor of u
        then D(v) = c(u,v) 
    else D(v) = ∞ 

LOOP
find w not in N' such that D(w) is a minimum
add w to N’ 
update D(v) for each neighbor v of w and not in N':
    D(v) = min(D(v), D(w) + c(w,v)) 
    new cost to v is either old cost to v or known least path cost to w plus cost from w to v
    until N' = N
*/

std::vector<node> dijkstra(node starting, std::vector<std::string> all_nodes, int node_num){
  all_nodes.push_back(starting.name);
  //creates the N’ array storing the order
  std::vector<node> final;
  final.push_back(starting);
  std::unordered_map<std::string, int> cost_arr;
  //initialising
  for(int i = 0; i < node_num; i++){
    std::string curr_node = all_nodes[i];
    if((starting.neighbour_nodes).find(curr_node) != starting.neighbour_nodes.end()){
      cost_arr[curr_node] = starting.neighbour_nodes[curr_node];
    }
    else{
      cost_arr[curr_node] = INT_MAX;
    }
  } 

  //create a vector of vector names that can be removed as the min is found and remove the starting node as its already in the final node
  std::vector<std::string> remaining_nodes = all_nodes;
  remaining_nodes = remove_element(remaining_nodes, starting.name);

  //for loop after initiation
  for(int i = 0; i < node_num-1; i++){
    int min_weight = INT_MAX;
    //for(int j = 0; j > remaining_nodes.size(); j++){
      
      //find w not in N' such that D(w) is a minimum
      //if()
      //add w to N’ 

      //update D(v) for each neighbor v of w and not in N':
      //D(v) = min(D(v), D(w) + c(w,v)) 
    //}
  }

  return final;
};

int main(){
  process_input();
  return 0;
}
